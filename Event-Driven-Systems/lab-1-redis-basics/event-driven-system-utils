"""
Base Event-Driven System Utilities
==================================

Reusable components for event-driven systems with Redis Streams.
Use this as foundation for future projects.
"""

import redis
import json
import uuid
import time
import threading
from datetime import datetime
from typing import Dict, Any, Optional, List, Callable


class EventBase:
    """Base class for event creation and validation"""
    
    @staticmethod
    def create_event(event_type: str, source: str, data: Dict[str, Any], version: str = "1.0") -> Dict[str, Any]:
        """
        Create standardized event structure
        
        Args:
            event_type: Type of event (e.g., 'order_placed', 'payment_processed')
            source: System that generated the event (e.g., 'website', 'mobile_app')
            data: Event payload/data
            version: Event schema version
            
        Returns:
            Standardized event dictionary
        """
        return {
            "event_id": str(uuid.uuid4()),
            "event_type": event_type,
            "timestamp": datetime.now().isoformat(),
            "source": source,
            "version": version,
            "data": json.dumps(data) if isinstance(data, dict) else data
        }
    
    @staticmethod
    def parse_event_data(event_fields: Dict[str, str]) -> Dict[str, Any]:
        """
        Parse event data from Redis stream fields
        
        Args:
            event_fields: Raw fields from Redis XREADGROUP
            
        Returns:
            Parsed event with data as dictionary
        """
        parsed = event_fields.copy()
        if 'data' in parsed and isinstance(parsed['data'], str):
            try:
                parsed['data'] = json.loads(parsed['data'])
            except json.JSONDecodeError:
                pass  # Keep as string if not valid JSON
        return parsed


class RedisConnection:
    """Redis connection manager with error handling"""
    
    def __init__(self, host: str = 'localhost', port: int = 6379, db: int = 0):
        self.host = host
        self.port = port  
        self.db = db
        self._client = None
    
    def connect(self) -> Optional[redis.Redis]:
        """
        Create and test Redis connection
        
        Returns:
            Redis client or None if connection fails
        """
        try:
            self._client = redis.Redis(
                host=self.host, 
                port=self.port, 
                db=self.db,
                decode_responses=True
            )
            self._client.ping()  # Test connection
            print(f"Connected to Redis at {self.host}:{self.port}")
            return self._client
        except redis.ConnectionError as e:
            print(f"Failed to connect to Redis: {e}")
            return None
    
    @property
    def client(self) -> redis.Redis:
        """Get Redis client, connect if needed"""
        if self._client is None:
            self.connect()
        return self._client


class EventProducer:
    """Base producer for publishing events to Redis Streams"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis_client = redis_client
    
    def publish_event(self, stream_name: str, event_type: str, source: str, data: Dict[str, Any]) -> bool:
        """
        Publish event to Redis stream
        
        Args:
            stream_name: Redis stream name (e.g., 'ecommerce:orders')
            event_type: Type of event
            source: Event source system
            data: Event payload
            
        Returns:
            True if successful, False otherwise
        """
        try:
            event = EventBase.create_event(event_type, source, data)
            message_id = self.redis_client.xadd(stream_name, event)
            print(f"Published {event_type} to {stream_name}: {message_id}")
            return True
        except Exception as e:
            print(f"Failed to publish event: {e}")
            return False
    
    def publish_events_async(self, generators: List[Callable]) -> None:
        """
        Run multiple event generators simultaneously using threads
        
        Args:
            generators: List of generator functions to run concurrently
        """
        threads = []
        
        for generator in generators:
            thread = threading.Thread(target=generator)
            threads.append(thread)
            thread.start()
        
        # Wait for all threads to complete
        for thread in threads:
            thread.join()
        
        print("All async producers finished!")


class EventConsumer:
    """Base consumer for processing events from Redis Streams"""
    
    def __init__(self, redis_client: redis.Redis, group_name: str, consumer_name: str):
        self.redis_client = redis_client
        self.group_name = group_name
        self.consumer_name = consumer_name
        self.event_handlers = {}
    
    def setup_consumer_group(self, stream_name: str) -> bool:
        """
        Create consumer group if it doesn't exist
        
        Args:
            stream_name: Redis stream name
            
        Returns:
            True if successful, False otherwise
        """
        try:
            self.redis_client.xgroup_create(stream_name, self.group_name, id='0', mkstream=True)
            print(f"Created consumer group '{self.group_name}' for stream '{stream_name}'")
            return True
        except redis.exceptions.ResponseError as e:
            if "BUSYGROUP" in str(e):
                print(f"Consumer group '{self.group_name}' already exists for stream '{stream_name}'")
                return True
            else:
                print(f"Error creating consumer group: {e}")
                return False
    
    def register_event_handler(self, event_type: str, handler: Callable):
        """
        Register handler function for specific event type
        
        Args:
            event_type: Event type to handle (e.g., 'order_placed')
            handler: Function to process the event
        """
        self.event_handlers[event_type] = handler
        print(f"Registered handler for event type: {event_type}")
    
    def process_event(self, event_fields: Dict[str, str], message_id: str, stream_name: str) -> bool:
        """
        Process single event using registered handlers
        
        Args:
            event_fields: Event fields from Redis
            message_id: Redis message ID
            stream_name: Stream name
            
        Returns:
            True if processed successfully, False otherwise
        """
        try:
            event_type = event_fields.get('event_type')
            
            if event_type in self.event_handlers:
                parsed_event = EventBase.parse_event_data(event_fields)
                self.event_handlers[event_type](parsed_event)
                return True
            else:
                print(f"No handler registered for event type: {event_type}")
                return False
                
        except Exception as e:
            print(f"Error processing event {message_id}: {e}")
            return False
    
    def start_consuming(self, streams: List[str], block_time: int = 1000) -> None:
        """
        Start consuming events from multiple streams
        
        Args:
            streams: List of stream names to consume from
            block_time: Block time in milliseconds (0 = no blocking)
        """
        # Setup consumer groups for all streams
        for stream in streams:
            self.setup_consumer_group(stream)
        
        print(f"Starting consumer '{self.consumer_name}' in group '{self.group_name}'")
        print(f"Consuming from streams: {streams}")
        print("Press Ctrl+C to stop...")
        
        try:
            while True:
                # Create stream dict for XREADGROUP
                stream_dict = {stream: ">" for stream in streams}
                
                messages = self.redis_client.xreadgroup(
                    self.group_name,
                    self.consumer_name,
                    stream_dict,
                    count=1,
                    block=block_time
                )
                
                if messages:
                    for stream_name, stream_messages in messages:
                        for message_id, fields in stream_messages:
                            print(f"\n--- Processing event from {stream_name} ---")
                            
                            success = self.process_event(fields, message_id, stream_name)
                            
                            if success:
                                # Acknowledge message
                                self.redis_client.xack(stream_name, self.group_name, message_id)
                                print(f"Acknowledged message {message_id}")
                            else:
                                print(f"Failed to process message {message_id}")
                                # In production: send to DLQ or retry queue
                
        except KeyboardInterrupt:
            print(f"\nConsumer '{self.consumer_name}' stopped by user")


class EventMonitor:
    """Utilities for monitoring Redis Streams"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis_client = redis_client
    
    def get_stream_info(self, stream_name: str) -> Dict[str, Any]:
        """Get stream information and statistics"""
        try:
            info = self.redis_client.xinfo_stream(stream_name)
            return {
                'length': info.get('length', 0),
                'first_entry': info.get('first-entry'),
                'last_entry': info.get('last-entry'),
                'groups': info.get('groups', 0)
            }
        except Exception as e:
            print(f"Error getting stream info: {e}")
            return {}
    
    def get_consumer_group_info(self, stream_name: str) -> List[Dict[str, Any]]:
        """Get consumer group information"""
        try:
            return self.redis_client.xinfo_groups(stream_name)
        except Exception as e:
            print(f"Error getting consumer group info: {e}")
            return []
    
    def get_pending_messages(self, stream_name: str, group_name: str) -> List[Any]:
        """Get pending messages for consumer group"""
        try:
            return self.redis_client.xpending(stream_name, group_name)
        except Exception as e:
            print(f"Error getting pending messages: {e}")
            return []
    
    def print_stream_stats(self, stream_names: List[str]) -> None:
        """Print statistics for multiple streams"""
        print("\n=== STREAM STATISTICS ===")
        for stream_name in stream_names:
            info = self.get_stream_info(stream_name)
            print(f"\nStream: {stream_name}")
            print(f"  Length: {info.get('length', 'N/A')}")
            print(f"  Groups: {info.get('groups', 'N/A')}")
            
            groups = self.get_consumer_group_info(stream_name)
            for group in groups:
                group_name = group.get('name')
                pending = self.get_pending_messages(stream_name, group_name)
                print(f"  Group '{group_name}': {len(pending)} pending messages")


# Common Event Data Generators
class EventDataGenerators:
    """Common data generators for testing and simulation"""
    
    @staticmethod
    def generate_order_data(source: str = "website") -> Dict[str, Any]:
        """Generate realistic order data"""
        products = [
            {"product_id": "laptop_123", "name": "Gaming Laptop", "price": 999.99},
            {"product_id": "phone_456", "name": "Smartphone", "price": 699.99},
            {"product_id": "tablet_789", "name": "Tablet", "price": 399.99},
            {"product_id": "watch_101", "name": "Smart Watch", "price": 299.99}
        ]
        
        import random
        selected_product = random.choice(products)
        quantity = random.randint(1, 3)
        
        return {
            "order_id": f"{source}_order_{uuid.uuid4().hex[:8]}",
            "customer_id": f"customer_{uuid.uuid4().hex[:6]}",
            "source": source,
            "items": [{
                "product_id": selected_product["product_id"],
                "name": selected_product["name"], 
                "quantity": quantity,
                "price": selected_product["price"]
            }],
            "total": selected_product["price"] * quantity
        }
    
    @staticmethod
    def generate_payment_data(order_id: str = None) -> Dict[str, Any]:
        """Generate realistic payment data"""
        import random
        
        methods = ["credit_card", "debit_card", "paypal", "bank_transfer"]
        statuses = ["completed", "pending", "failed"]
        
        return {
            "payment_id": f"pay_{uuid.uuid4().hex[:8]}",
            "order_id": order_id or f"order_{uuid.uuid4().hex[:8]}",
            "amount": round(random.uniform(50.0, 1500.0), 2),
            "method": random.choice(methods),
            "status": random.choice(statuses)
        }


# Example Usage Functions
def example_producer_usage():
    """Example of how to use the base classes for producing events"""
    
    # Setup
    redis_conn = RedisConnection()
    redis_client = redis_conn.connect()
    producer = EventProducer(redis_client)
    
    # Publish single event
    order_data = EventDataGenerators.generate_order_data("website")
    producer.publish_event("ecommerce:orders", "order_placed", "website", order_data)
    
    # Publish multiple events async
    def website_orders():
        for _ in range(5):
            data = EventDataGenerators.generate_order_data("website")
            producer.publish_event("ecommerce:orders", "order_placed", "website", data)
            time.sleep(2)
    
    def mobile_orders():
        for _ in range(3):
            data = EventDataGenerators.generate_order_data("mobile_app")
            producer.publish_event("ecommerce:orders", "order_placed", "mobile_app", data)
            time.sleep(3)
    
    producer.publish_events_async([website_orders, mobile_orders])


def example_consumer_usage():
    """Example of how to use the base classes for consuming events"""
    
    # Setup
    redis_conn = RedisConnection()
    redis_client = redis_conn.connect()
    consumer = EventConsumer(redis_client, "processors", "worker_1")
    
    # Define event handlers
    def handle_order_placed(event):
        data = event['data']
        print(f"Processing order: {data['order_id']} - Total: ${data['total']}")
    
    def handle_payment_processed(event):
        data = event['data'] 
        print(f"Processing payment: {data['payment_id']} - Amount: ${data['amount']}")
    
    # Register handlers
    consumer.register_event_handler("order_placed", handle_order_placed)
    consumer.register_event_handler("payment_processed", handle_payment_processed)
    
    # Start consuming
    consumer.start_consuming(["ecommerce:orders", "ecommerce:payments"])


if __name__ == "__main__":
    print("Event-Driven System Base Classes")
    print("Import this module to use the base classes in your projects!")
    
    # Uncomment to run examples:
    # example_producer_usage()
    # example_consumer_usage()